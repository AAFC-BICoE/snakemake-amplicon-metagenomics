""" Oksana Korol, June 15, 2016

Amplicon Metagenomics Workflow for GRDI EcoBiomics project.

Version 0.1 (trial)

Steps of the workflow:
1. Trimming
Tool: trimmomatic version 0.36

2. Overlapping - aligning forward and reverse sequences
Tool: Qiime. Script: join_paired_ends.py. This script have to be substituted for multiple_join_paired_ends.py in HPC cluster.

3. Chimera checking
Tool: Qiime. identify_chimeric_seqs.py script. This step may end up being moved after OTU clustering and picking representative sequences. Since it takes a lot of processing time, it might make sense to execute it on representative sequences, instead of the whole set.

4. OTU Picking and classification
Tools: Qiime. Scripts:
 *  pick_de_novo_otus.py did not work well on the test data, but is very convenient and has all the steps embedded. It does not have an option to cluster using CD-HIT, though.
 *  Sequence of manual steps:
    -    Cluster OTU: pick_otus.py
    -    Pick representative sequences: pick_rep_set.py
    -    Classify: assign_taxonomy.py
    -    Make OTU: make_otu_table.py

"""

configfile: "config.yaml"

# Workdir can be changed when executing workflow:
# snakemake --config workdir="data/amplicon_workflow/"
workdir: config["workdir"]

rule all:
    input:
        #"step1_trimmomatic/output_R1_paired.fastq",
        #"step1_trimmomatic/output_R2_paired.fastq"
        "step7_otu/otu_table.otu"

rule initial_data_quality:
    version: "0.11.2"
    input:
        config["initial_input_forward"],
        config["initial_input_reverse"],
    output:
        "step0_initial_data_quality/input_ENV0047_S21_R1_001_fastqc.html",
        "step0_initial_data_quality/input_ENV0047_S21_R2_001_fastqc.html",
    message:
        "\n ===== Running FastQC to determine the quality of the initial input data."
    benchmark:
        "benchmarks/step0_initial_data_quality.txt"
    threads: config["threads"]
    shell:
        """
        initial_data_quality_cmd="fastqc {input} --outdir=step0_initial_data_quality" ;\
        echo "Executed command:\n" $initial_data_quality_cmd ;\
        $initial_data_quality_cmd 
        """

rule trimm:
    version: "0.36"
    input:
        forward = config["initial_input_forward"],
        reverse = config["initial_input_reverse"],
        quality = "step0_initial_data_quality/input_ENV0047_S21_R1_001_fastqc.html",
    output:
        forward_paired = "step1_trimmomatic/output_R1_paired.fastq",
        reverse_paired = "step1_trimmomatic/output_R2_paired.fastq",
        #forward_unpaired = "step1_trimmomatic/output_R1_unpaired.fastq",
        #reverse_unpaired = "step1_trimmomatic/output_R2_unpaired.fastq",
    params:
        output_dir = "step1_trimmomatic"
    message:
        "\n ===== Trimming input sequences with Trimomatic 0.36"
    benchmark:
        "benchmarks/step1_trimmomatic.txt"
    threads: config["threads"]
    shell:
        """
        java -jar ~/bin/trimmomatic-0.36.jar PE -threads 8 -phred33 {input.forward} {input.reverse} \
        {output.forward_paired} {params.output_dir}/output_R1_unpaired.fastq {output.reverse_paired} {params.output_dir}/output_R2_unpaired.fastq \
        LEADING:{config[trimmomatic][LEADING]} TRAILING:{config[trimmomatic][TRAILING]} SLIDINGWINDOW:{config[trimmomatic][SLIDINGWINDOW]} \
        MINLEN:{config[trimmomatic][MINLEN]}
        """
        #LEADING:3 TRAILING:3 SLIDINGWINDOW:4:15 MINLEN:36

rule trimm_quality:
    version: "0.11.2"
    input:
        "step1_trimmomatic/output_R1_paired.fastq",
        "step1_trimmomatic/output_R2_paired.fastq"
    output:
        "step1_trimmomatic/quality/output_R1_paired_fastqc.html",
        "step1_trimmomatic/quality/output_R2_paired_fastqc.html"
    message:
        "\n ===== Running FastQC to check quality of the trimming."
    benchmark:
        "benchmarks/step1_trimmomatic_quality.txt"
    threads: config["threads"]
    shell:
        """
        trimm_quality_cmd="fastqc {input} --outdir=step1_trimmomatic/quality" ;\
        echo "Executed command:\n" $trimm_quality_cmd ;\
        $trimm_quality_cmd
        """

rule join:
    version: "1.9"
    input:
        forward_paired = "step1_trimmomatic/output_R1_paired.fastq",
        reverse_paired = "step1_trimmomatic/output_R2_paired.fastq",
        quality = "step1_trimmomatic/quality/output_R1_paired_fastqc.html"
    output:
        joined_seqs = "step2_join/fastqjoin.join.fastq",
        #unjoined_forward_seqs = "step2_join/fastqjoin.un1.fastq",
        #unjoined_reverse_seqs = "step2_join/fastqjoin.un2.fastq",
    message:
        "\n ===== Joining forward and reverse paired-end sequences with Qiime 1.9 join_paired_ends.py script."
    benchmark:
        "benchmarks/step2_join.txt"
    threads: config["threads"]
    shell:
        """
        join_cmd="join_paired_ends.py -f {input.forward_paired} -r {input.reverse_paired} -o step2_join/ -m fastq-join" ;\
        echo "Executed command:\n" $join_cmd ;\
        $join_cmd
        """
        #-j 20 -p 2

rule join_quality:
    version: "0.11.2"
    input:
        "step2_join/fastqjoin.join.fastq"
    output:
        "step2_join/quality/fastqjoin.join_fastqc.html"
    message:
        "Running FastQC to check quality of the join."
    benchmark:
        "benchmarks/step2_join_quality.txt"
    threads: config["threads"]
    shell:
        """
        join_quality_cmd="fastqc {input} --outdir=step2_join/quality" ;\
        echo "Executed command:\n" $join_quality_cmd ;\
        $join_quality_cmd
        """

rule convert_fastq_to_fasta:
    input:
        fastq = "step2_join/fastqjoin.join.fastq",
        quality = "step2_join/quality/fastqjoin.join_fastqc.html"
    output:
        "step3_convert_to_fasta/trimmed_joined.fasta"
    message:
        "\n ===== Converting fastq files to fasta."
    benchmark:
        "benchmarks/step3_convert_to_fasta.txt"
    threads: config["threads"]
    shell:
        """
        awk 'BEGIN{{P=1}}{{if(P==1||P==2){{gsub(/^[@]/,">");print}}; if(P==4)P=0; P++}}' {input.fastq} > {output}
        """ 

rule cluster_otus:
    version: "1.9"
    input:
        "step3_convert_to_fasta/trimmed_joined.fasta"
    output:
        "step4_pick_otu/trimmed_joined_otus.txt"
    message:
        "\n ===== Cluster sequences into OTUs (Operational Taxonomic Units)"
    benchmark:
        "benchmarks/step4_pick_otu.txt"
    threads: config["threads"]
    shell:
        """
        cluster_otus_cmd="pick_otus.py -i {input} -m cdhit -s {config[pick_otus][s]} -o step4_pick_otu" ;\
        echo "Executed command:\n" $cluster_otus_cmd ;\
        $cluster_otus_cmd
        """

rule pick_representatives:
    version: "1.9"
    input:
        otu = "step4_pick_otu/trimmed_joined_otus.txt",
        fasta = "step3_convert_to_fasta/trimmed_joined.fasta"
    output:
        "step5_pick_representatives/rep_set.fasta"
    message:
        "\n ===== Pick a representative sequence for each OTU."
    benchmark:
        "benchmarks/step5_pick_representatives.txt"
    threads: config["threads"]
    shell:
        """
        pick_representatives_cmd="pick_rep_set.py -i {input.otu} -f {input.fasta} -o {output}" ;\
        echo "Executed command:\n" $pick_representatives_cmd ;\
        $pick_representatives_cmd
        """

rule classify:
    version: "1.9"
    input:
        dataset = "step5_pick_representatives/rep_set.fasta",
        reference_fasta = "unite.fasta",
        reference_txt = "unite.txt"
    output:
        "step6_classify/rep_set_tax_assignments.txt"
    message:
        "\n ===== Classify (i.e. assign taxonomy) to representative sequences."
    benchmark:
        "benchmarks/step6_classify.txt"
    threads: config["threads"]
    shell:
        """
        classify_cmd="assign_taxonomy.py -i {input.dataset} -m mothur -r {input.reference_fasta} -t {input.reference_txt} \
        -c {config[assign_taxonomy][c]} -o step6_classify" ;\
        echo "Executed command:\n" $classify_cmd ;\
        $classify_cmd
        """

rule make_otu:
    version: "1.9"
    input: 
        assigned_taxonomy = "step6_classify/rep_set_tax_assignments.txt",
        otu = "step4_pick_otu/trimmed_joined_otus.txt"
    output:
        "step7_otu/otu_table.biom"
    message:
        "\n ===== Make OTU table as a biom file. \n Biom file: the columns correspond to Samples and rows correspond to OTUs and the number of times a sample appears in a particular OTU."
    benchmark:
        "benchmarks/step7_otu_make_otu.txt"
    threads: config["threads"]
    shell:
        """
        make_otu_cmd="make_otu_table.py -i {input.otu} -t {input.assigned_taxonomy} -o {output}" ;\
        echo "Executed command:\n" $make_otu_cmd ;\
        $make_otu_cmd
        """

rule convert_otu_table:
    input:
        "step7_otu/otu_table.biom"
    output:
        "step7_otu/otu_table.otu"
    message:
        "\n ===== Convert OTU table in biom format to tab-delimited table format. "
    benchmark:
        "benchmarks/step7_otu_convert_otu.txt"
    threads: config["threads"]
    shell:
        """
        convert_otu_table_cmd="biom convert -i {input} -o {output} --to-tsv" ;\
        echo "Executed command:\n" $convert_otu_table_cmd ;\
        $convert_otu_table_cmd
        """